#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "board.h"
#include "pool.h"


#define POOL_FILENAME_SEP       '_'

#define FLAG_POST_CHAR          'p'
#define FLAG_REPLY_CHAR         'r'
#define FLAG_MODIFY_CHAR        'e'
#define FLAG_DELETE_CHAR        'd'
#define FLAG_DELETE_RANGE_CHAR  'D'

#define POOL_FILENAME_MIN       26  /* 1 op, 4 _, 1 ., 6 x, 14 date  */


static const char*
rindex_end(const char* s, const char* end, char c)
{
    if (end < s)
        return NULL;

    while (*end != c)
        if (--end < s)
            return NULL;

    return end;
}


/*
 * filename templates:
 *      delete: d_yyyymmddHHMMSS_bid_author_id.xxxxxx
 *              D_yyyymmddHHMMSS_bid_author_id1_id2.xxxxxx
 *      post:   p_yyyymmddHHMMSS_bid_author.xxxxxx
 *      reply:  r_yyyymmddHHMMSS_bid_author_id.xxxxxx
 *      modify: e_yyyymmddHHMMSS_bid_author_id.xxxxxx
 *
 *  where xxxxxx are used to store random strings generated by mkstemp()
 */
board_op_t
parse_pool_file_name(const char* filename, unsigned short* bid,
                     unsigned* id1, unsigned* id2)
{
    const char* p;
    char* end;
    size_t len;

    board_op_t op;
    unsigned long id;

    assert(NULL != filename && NULL != id1 && NULL != id2);

    len = strlen(filename);
    if (len < POOL_FILENAME_MIN)
        return OP_INVALID;

    if (POOL_FILENAME_SEP != *(filename + 1))
        return OP_INVALID;

    /* get bid  */
    p = filename + 17;
    id = strtoul(p, &end, 10);
    if (! IS_VALID_BOARD_ID(id))
        return OP_INVALID;
    *bid = (unsigned short)id;

    /* get op   */
    switch (*filename) {
    case FLAG_POST_CHAR:
        return OP_POST;
    case FLAG_REPLY_CHAR:
        op = OP_REPLY;
        break;
    case FLAG_MODIFY_CHAR:
        op = OP_MODIFY;
        break;
    case FLAG_DELETE_CHAR:
        op = OP_DELETE;
        break;
    case FLAG_DELETE_RANGE_CHAR:
        op = OP_DELETE_RANGE;
        break;
    default:
        return OP_INVALID;
    }

    /* get id or id2    */
    p = filename + len - 8;     /* the character before last dot    */
    p = rindex_end(filename, p, POOL_FILENAME_SEP);
    if (NULL == p)
        return OP_INVALID;
    id = strtoul(p + 1, &end, 10);
    if (! IS_VALID_ARTICLE_ID(id))
        return OP_INVALID;

    if (OP_DELETE_RANGE == op) {
        /* get id1  */
        p = rindex_end(filename, p - 1, POOL_FILENAME_SEP);
        if (NULL == p)
            return OP_INVALID;
        *id2 = (unsigned)id;
        id = strtoul(p + 1, &end, 10);
        if (! IS_VALID_ARTICLE_ID(id))
            return OP_INVALID;
        *id1 = (unsigned)id;
    } else {
        *id1 = (unsigned)id;
    }

    return op;
}


size_t
generate_pool_file_name(char* filename, size_t len, board_op_t op, time_t* t,
                        const char* author, unsigned short bid, unsigned id1,
                        unsigned id2)
{
    char flag;
    char timestamp[15];
    int n;

    if (sizeof(timestamp) - 1 != strftime(timestamp, sizeof(timestamp),
                                                "%Y%m%d%H%M%S", localtime(t)))
        return -1;

    switch (op) {
    case OP_POST:
        flag = FLAG_POST_CHAR;
        break;
    case OP_REPLY:
        flag = FLAG_REPLY_CHAR;
        break;
    case OP_MODIFY:
        flag = FLAG_MODIFY_CHAR;
        break;
    case OP_DELETE:
        flag = FLAG_DELETE_CHAR;
        break;
    case OP_DELETE_RANGE:
        flag = FLAG_DELETE_RANGE_CHAR;
        break;
    default:
        return 0;
    }

    n = snprintf(filename, len, "%c_%s_%hu_%s.XXXXXX",
                 flag, timestamp, bid, author);
    if(n <= 0 || (size_t)n >= len)
        return 0;

    return n;
}

