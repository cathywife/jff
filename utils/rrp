#!/bin/bash
#
# rrp, a not fully wrapper to repo and GIT
#
# Purpose
#   This little script is aimed to provide simple
#   CLI to imitate Subversion and help to archive
#   a centralized administered software development
#   model.
#
# License
#   GPL v3
#
# Authors
#   Liu Yubao <yubao.liu@gmail.com>
#
# ChangeLog
#   2008-11-04  Liu Yubao
#       * initial skeleton, implement help command
#
#   2008-11-05  Liu Yubao
#       * implement checkout/update/commit/uncommit, v0.1
#       * cleanup ssh-agent when this script exits, v0.2
#       * make remote client can access repository, v0.3
#
#   2008-11-06  Liu Yubao
#       * check whether updated when commit
#       * clarify 'module' and 'project' words
#       * implement ls command
#       * fix bug in initialize() when MODULE_ROOT is null, v0.4
#       * implement review command, v0.5
#
#   2008-11-11  Liu Yubao
#       * refer branch name more strictly, v0.6
#       * old git doesn't support --depth=1, use --depth 1 instead, v0.7
#       * make messages more attractive by ASCII character frame
#       * don't download from android.git.kernel.org because it's
#         very slow sometimes
#       * update $HOME/repo to new version automatically
#
#   2008-11-12  Liu Yubao
#       * make sure commit_module() run in root directory of a module
#       * add showbranch, whatupdated, diff, status and for all commands
#       * don't switch to branch "my" after `rrp update' because we
#         are maybe already on it, v0.8
#       * add missed "&&" to cache_ssh_private_key(), v0.9
#       * optimize efficience of cmd_commit()
#       * add progress indicator for cmd_commit() and cmd_uncommit(), v0.10
#       * correct "echo" to "read" in initialize(), v0.11
#
#   2008-11-13  Liu Yubao
#       * implement cherry command
#       * implement reasonable behaviour of whatupdated, v0.12
#       * use SSH_AUTH_SOCK to tell whether ssh-agent is required
#         because GNOME seahorse doesn't expose SSH_AUTH_SOCK
#
#   2008-11-14  Liu Yubao
#       * make show-branch and what-updated synonyms for showbranch
#         and whatupdated
#
#   2008-11-16  Liu Yuao
#       * make `less' not use alternate screen with -X option
#       * add `editlog' command
#       * output colorful important running command
#       * add module name and branch name to PS1, v0.13
#
#   2008-11-17  Liu Yubao
#       * enclose ANSI escape sequences in PS1 with \[ and \]
#         to avoid garbled output for long input line
#       * don't use black background for run_cmd()
#       * give cmd_update's arguments to `repo sync' to update
#         explicitly some modules, v0.14
#
#   2008-11-26  Liu Yubao
#       * add `log` command, v0.15
#       * fix incompatible syntax in expr command, v0.16
#
# TODO:
#   fix many problems in cmd_update().
#   `bisect' command.

######################## part executed in $HOME/.bashrc ################
# To make the pollution to shell environment minimum, I put this code
# snippet here for setting PS1.
#
__rrp_find_dir () {
    local d=$1
    local dir=$(pwd)

    while [ -n "$dir" ]; do
        [ -d "$dir/$d" ] && break
        dir=$(dirname $dir)
        [ "$dir" = "/" ] && dir= && break
    done

    echo "$dir"
}


__rrp_ps1 () {
    local PROJECT_ROOT=$(__rrp_find_dir '.repo')
    local MODULE_ROOT=$(__rrp_find_dir '.git')
    local module

    # project_root is empty or module_root is out of project_root, we
    # get a wrong module_root, so set it empty
    [ -z "$PROJECT_ROOT" ] ||
        [ "$PROJECT_ROOT" != "$(expr substr "$MODULE_ROOT" 1 $(expr length "$PROJECT_ROOT"))" ] &&
        MODULE_ROOT=

    module=${MODULE_ROOT#$PROJECT_ROOT/}
    echo $(__git_ps1 "$module(%s)")
}


if [ "$1" = "ps1" ]; then
    if [ "$(type -t "__git_ps1")" != 'function' ]; then
        echo "git completion isn't enabled, please check your ~/.bashrc to uncomment" >&2
        echo "'. /etc/bash_completion' or append '. /path/to/git-completion.sh' to .bashrc" >&2
    else
        PS1='[$SHLVL]\[\033[01;31m\]$(__rrp_ps1)\[\033[00m\]'"$PS1"
    fi

    return
fi

######################## constant vars #################################
# version of this little script
RRP_VERSION=0.16

# IP of the server containing central repository
SERVER_IP=192.168.88.5
# Port of the ssh service on the server
SERVER_PORT=22
# path of the official repository
REPOS_PATH=/src/android/android
# path of the temporary repository
HOT_REPOS_PATH=/src/android/android-hot
# default remote
DEFAULT_REMOTE=origin
# default upstream branch
DEFAULT_UPSTREAM_BRANCH=master
# default working branch
DEFAULT_WORKING_BRANCH=my
# path where to place script "repo"
REPO=$HOME/repo
# ref updates of upstream branch in every modules happening in
# $UPDATE_INTERVAL seconds are thought as one update of whole android project
UPDATE_INTERVAL=300


######################## global vars ###################################
# The directory that contains .repo
PROJECT_ROOT=
# The directory that contains .git
MODULE_ROOT=
# Does the working copy lie in same machine with central repository?
IS_LOCAL=
# remote url for official repository to pull baseline code
PULL_REPOS_PATH=
# remote url for temporary repository to push changes
PUSH_REPOS_PATH=
# user account, eg yubaoliu
USER_ACCOUNT=
# user name, eg "Liu Yubao"
USER_NAME=
# user email, eg yubao.liu@gmail.com
USER_EMAIL=
# is ssh-agent started by this script?
IS_NEW_SSH_AGENT=


######################## auxiliary functions ###########################


run_cmd () {
    # see repo/color.py for color ANSI escape sequences
    echo -ne "\033[01;31m"      # bold, red foreground
    echo [CMD] "$@"
    echo -ne "\033[00m"         # reset color
    "$@"
}


has_sub_command () {
    test "$(type -t "cmd_$1")" = 'function'
}


install_ps1_setting_to_bashrc () {
    grep -q "rrp ps1" $HOME/.bashrc 2>/dev/null ||
        cat >> $HOME/.bashrc <<EOF

# !!! Inserted by rrp to show android module path and branch name
# in shell prompt. If you don't like it, comment out next line.
. /usr/local/bin/rrp ps1    # DON'T REMOVE THIS LINE

EOF
}


initialize () {
    PROJECT_ROOT=$(__rrp_find_dir '.repo')
    MODULE_ROOT=$(__rrp_find_dir '.git')

    # project_root is empty or module_root is out of project_root, we
    # get a wrong module_root, so set it empty
    [ -z "$PROJECT_ROOT" ] ||
        [ "$PROJECT_ROOT" != "$(expr substr "$MODULE_ROOT" 1 $(expr length "$PROJECT_ROOT"))" ] &&
        MODULE_ROOT=

    install_ps1_setting_to_bashrc

    /sbin/ifconfig | grep -qF $SERVER_IP && IS_LOCAL=1

    which git >/dev/null 2>&1 || { echo "git isn't installed!" >&2; exit 1; }

    if [ ! -f $HOME/.ssh/id_rsa ]; then
        echo "+-------------------------------------------------------------------+"
        echo "| Run ssh-keygen for you, please use default path and you'd better  |"
        echo "| supply password to protect your private key.                      |"
        echo "+-------------------------------------------------------------------+"
        echo

        run_cmd ssh-keygen

        echo
        echo "+-------------------------------------------------------------------+"
        echo "| \$HOME/.ssh/id_rsa.pub is your public key, send it to              |"
        echo "| your administrator whenever you create a new one.                 |"
        echo "| !!! You CAN'T access the source code repository until the         |"
        echo "| !!! administrator finishes the configuration for you.             |"
        echo "+-------------------------------------------------------------------+"

        exit 1
    fi

    USER_ACCOUNT=$USER
    if [ ! -f $HOME/.ssh/config ] || ! grep -qF $SERVER_IP $HOME/.ssh/config; then
        local u

        read -t 30 -p "What's your git account on $SERVER_IP?[$USER_ACCOUNT-git]" u

        [ -n "$u" ] && USER_ACCOUNT=${u%-git}
        echo "Write account settings for $SERVER_IP to $HOME/.ssh/config."
        {
            echo "Host $SERVER_IP"
            echo "    Port $SERVER_PORT"
            echo "    User $USER_ACCOUNT-git"
        } >> $HOME/.ssh/config
        sleep 2
    else
        local key arg ready
        while read key arg; do
            key=$(echo $key | tr [:upper:] [:lower:])
            case "$key,$arg,$ready" in
                host,$SERVER_IP,)
                    ready=1
                    ;;
                user,*,1)
                    USER_ACCOUNT=${arg%-git}
                    ready=
                    ;;
            esac
        done < $HOME/.ssh/config
    fi

    if [ "$IS_LOCAL" ]; then
        PULL_REPOS_PATH=$REPOS_PATH
    else
        PULL_REPOS_PATH=ssh://$USER_ACCOUNT-git@$SERVER_IP:$SERVER_PORT$REPOS_PATH
    fi
    PUSH_REPOS_PATH=ssh://$USER_ACCOUNT-git@$SERVER_IP:$SERVER_PORT$HOT_REPOS_PATH

    # copy new "repo" script to $HOME/repo
    local new_repo="$PROJECT_ROOT/.repo/repo/repo"
    local old_repo="$HOME/repo"
    if [ -x "$new_repo" ]; then
        [ -x "$old_repo" ] && diff "$old_repo" "$new_repo" >/dev/null 2>&1 ||
            cp  "$new_repo" "$old_repo" || exit 1
    fi
}


finalize () {
    test $IS_NEW_SSH_AGENT && {
        [ -n "$SSH_AGENT_PID" ] && kill "$SSH_AGENT_PID"
        [ -n "$SSH_AUTH_SOCK" ] && { rm "$SSH_AUTH_SOCK"; rmdir "$(basename "$SSH_AUTH_SOCK")"; }
    } >/dev/null 2>&1
}


must_under_project_root () {
    [ -z "$PROJECT_ROOT" ] &&
        echo .repo not found in current directory and its upper directories! >&2 &&
        exit 1
}


must_under_module_root () {
    [ -z "$MODULE_ROOT" ] &&
        echo .git not found in current directory and its upper directories! >&2 &&
        exit 1
}


must_has_git_dir_in_module () {
    [ ! -d "$PROJECT_ROOT/$1/.git" ] &&
        echo "No module \"$1\" found." >&2 &&
        exit 1
}

cache_ssh_private_key () {
    [ -z "$SSH_AUTH_SOCK" ] &&
        echo "+-------------------------------------------------------------------+" &&
        echo "| ssh-agent not running, you'd better execute \`eval \$(ssh-agent)'   |" &&
        echo "| or \`ssh-agent bash', then execute \`ssh-add' to avoid being        |" &&
        echo "| asked for password again and again.                               |" &&
        echo "+-------------------------------------------------------------------+" &&
        eval $(ssh-agent) &&
        IS_NEW_SSH_AGENT=1 &&
        ssh-add
}


local_updated_and_has_new_commit () {
    local module=$1
    local branch=refs/heads/$USER_ACCOUNT/$DEFAULT_UPSTREAM_BRANCH/$DEFAULT_WORKING_BRANCH
    local baserev=$(git show-ref -s refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH)
    local newrev=$(git show-ref -s refs/heads/$DEFAULT_WORKING_BRANCH)

    if [ -z "$newrev" ]; then
        echo
        echo "$module: local branch \`$DEFAULT_WORKING_BRANCH\' not found!" >&2
        return 1
    fi

    [ "$baserev" = "$newrev" ] && return 1

    if [ $(git merge-base $baserev $newrev) != $baserev ]; then
        {
            echo
            echo "$module is out of date, please update it using the command below first!"
            echo
            echo "  1. cd $module"
            echo "  2. git checkout $DEFAULT_WORKING_BRANCH"
            echo "  3. git fetch $DEFAULT_REMOTE"
            echo "  4. git rebase $DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH"
            echo "     or"
            echo "     git merge $DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH"
            echo
        } >&2
        exit 1      # don't return 1 because this function can be called many times, the tip above
                    # can be too noisy.
    fi

    local oldrev=$(git ls-remote --heads $PUSH_REPOS_PATH/$module $branch)
    oldrev=${oldrev%% *}

    test "$oldrev" != "$newrev"
}


commit_module () {
    local module=$1

    git fetch

    if local_updated_and_has_new_commit $module; then
        echo
        run_cmd git push -f $PUSH_REPOS_PATH/$module \
                $DEFAULT_WORKING_BRANCH:refs/heads/$USER_ACCOUNT/$DEFAULT_UPSTREAM_BRANCH/$DEFAULT_WORKING_BRANCH
    #else
    #    echo "No new local commits on branch '$DEFAULT_WORKING_BRANCH' of module '$module'."
    fi
}


uncommit_module () {
    local module=$1

    local branch=refs/heads/$USER_ACCOUNT/$DEFAULT_UPSTREAM_BRANCH/$DEFAULT_WORKING_BRANCH
    if [ 1 -eq $(git ls-remote --heads $PUSH_REPOS_PATH/$module $branch | wc -l) ]; then
        echo
        run_cmd git push -f $PUSH_REPOS_PATH/$module \
                0000000000000000000000000000000000000000:$branch
    #else
    #    echo "No branch '$branch' found in module '$PUSH_REPOS_PATH/$module'."
    fi
}


showbranch () {
    local path="$1"

    local n rev head heads
    n=$( (git show-ref -s --heads;
          git show-ref -s refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH) | uniq | wc -l)

    [ $n -eq 1 ] && return 0

    heads=$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH
    while read rev head; do
        heads="$heads ${head#refs/heads/}"
    done < <(git show-ref --heads)

    echo "========================================================================"
    echo "$path"
    echo
    git show-branch $heads
}


cherry () {
    local path="$1"

    local upstream=refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH
    local upstream_rev=$(git show-ref -s $upstream)
    local n
    n=$( (git show-ref -s --heads; echo $upstream_rev) | uniq | wc -l )

    [ $n -eq 1 ] && return 0

    echo "========================================================================"
    echo "$path"
    echo

    local rev head
    while read rev head; do
        [ $rev != $upstream_rev ] && run_cmd git cherry -v $upstream $head
    done < <(git show-ref --heads)
}


whatupdated () {
    local path="$1"

    local latest_rev prev_rev

    latest_rev=$(git rev-parse -q refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH@{0} 2>/dev/null)
    prev_rev=$(git rev-parse -q refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH@{1} 2>/dev/null)

    [ '0000000000000000000000000000000000000000' = $latest_rev ] && return 1

    echo "========================================================================"
    echo "$path"
    echo

    [ '0000000000000000000000000000000000000000' = $prev_rev ] &&
        git log --color --stat $latest_rev ||
        git log --color --stat $prev_rev..$latest_rev
}


last_reflog_time () {
    local log=$(tail -n 1 ".git/logs/refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH" 2>/dev/null)

    [ -z "$log" ] && return

    local begin end
    begin=$(expr "$log" : ".*> ")
    end=$(expr "$log" : ".*> [0-9]\+ ")

    [ $begin -eq 0 -o $end -le $begin ] && return

    echo $(expr substr "$log" $begin $(expr $end - $begin))
}


######################## sub commands ##################################
cmd_help () {
    if [ -z "$1" ]; then
        cat <<EOF
rrp, a not fully wrapper to repo and GIT, v$RRP_VERSION

Usage:
  rrp COMMAND [options] [arguments]

Available commands:
  checkout  - check out a working copy from repository
  update    - update working copy from repository

  commit    - commit changes to central repository
  uncommit  - cancel commits to central repository

  editlog   - edit log of some commit on current branch

  review    - review commits to repository

  ls        - list modules
  log       - show log for whole android project
  status    - show the working tree status
  diff      - show changes between working tree, index and commit
  cherry    - find commits not merged upstream
  showbranch    - show branches and their commits
  whatupdated   - show what changed in the last update or fetch

  forall    - execute command in each module's root directory

See 'rrp help COMMAND' for more information on a specific command.
EOF
    else
        local cmd="$1"
        if has_sub_command "$cmd"; then
            echo "Sorry, no detailed help yet."
        else
            echo "Unkown command, run 'rrp help' for help information." >&2
        fi
    fi
}


cmd_checkout () {
    # make sure not in a working copy
    if [ -n "$PROJECT_ROOT" ]; then
        echo "Can't checkout into an existed working copy!" >&2
        exit 1
    fi

    # make sure in a empty directory
    if [ $(ls -a | wc -l) -gt 2 ]; then
        echo "Current directory isn't empty!" >&2
        exit 1
    fi

    # accessing remote repository requires private key
    [ "$IS_LOCAL" ] || cache_ssh_private_key

    # install script "repo" from android.git.kernel.org
    if [ ! -x $REPO ]; then
        run_cmd git clone --depth 1 $PULL_REPOS_PATH/.repo/repo
        if [ -f repo/repo ]; then
            run_cmd cp -i repo/repo $REPO
        else
            exit 1
        fi
        chmod u+x $REPO
        rm -rf repo
    fi

    # initialize working copy
    run_cmd $REPO init -u $PULL_REPOS_PATH/.repo/manifests.git \
            -b $(test "$IS_LOCAL" && echo $DEFAULT_UPSTREAM_BRANCH-local || echo $DEFAULT_UPSTREAM_BRANCH) || exit 1

    # get customized script "repo"
    if [ "$IS_LOCAL" ]; then
        run_cmd cd .repo/repo &&
            run_cmd git fetch $REPOS_PATH/.repo/repo alternates-repo:alternates-repo &&
            run_cmd git checkout alternates-repo -- &&
            run_cmd cd - || exit 1
    fi

    # fetch android source code and create a working branch
    run_cmd $REPO sync &&
    run_cmd $REPO start $DEFAULT_WORKING_BRANCH
}


cmd_update () {
    must_under_project_root
    cache_ssh_private_key

    run_cmd $REPO sync "$@"
    #run_cmd $REPO start $DEFAULT_WORKING_BRANCH "$@"
}


cmd_commit () {
    must_under_project_root
    cache_ssh_private_key

    local module=${MODULE_ROOT#$PROJECT_ROOT/}

    if [ -z "$module" ]; then   # in project_root directory
        module=$1
        [ -z "$1" ] &&          # no arguments given
            $REPO forall -c pwd 2>/dev/null | while read module; do
                module=${module#$PROJECT_ROOT/}

                printf '\r%-60s ... ' "$module"
                cd "$PROJECT_ROOT/$module" && commit_module $module
                printf '%d modules processed.' $((++n))
            done ||             # has arguments given
            while shift; do
                must_has_git_dir_in_module $module

                printf '\r%-60s ... ' "$module"
                cd "$PROJECT_ROOT/$module" && commit_module $module
                printf '%d modules processed.' $((++n))

                module=$1
            done

            echo
    else                        # in sub directory of project_root directory
        commit_module $module
    fi
}


cmd_uncommit () {
    cache_ssh_private_key

    local module=$1

    if [ -z "$module" ]; then     # no arguments given
        must_under_project_root

        module=${MODULE_ROOT#$PROJECT_ROOT/}
        [ -n "$module" ] && uncommit_module $module ||
            $REPO forall -c pwd | while read module; do
                module=${module#$PROJECT_ROOT/}

                printf '\r%-60s ... ' "$module"
                uncommit_module $module
                printf '%d modules processed.' $((++n))

            done
    else                        # has arguments given
        while shift; do
            printf '\r%-60s ... ' "$module"
            uncommit_module $module
            printf '%d modules processed.' $((++n))

            module=$1
        done
    fi

    echo
}


cmd_review () {
    must_under_module_root
    cache_ssh_private_key

    local author=${1:-$USER_ACCOUNT}
    local module=${MODULE_ROOT#$PROJECT_ROOT/}

    if ! git remote | grep -qw $DEFAULT_REMOTE-hot; then
        local url=$(git remote -v | grep -w "^$DEFAULT_REMOTE")
        url=${url##*.repo/projects/}
        if [ -z "$url" ]; then
            echo "GIT remote \`$DEFAULT_REMOTE' not found!" >&2
            exit 1
        fi

        url=$PUSH_REPOS_PATH/.repo/projects/$url
        run_cmd git remote add -m $DEFAULT_UPSTREAM_BRANCH-hot -f $DEFAULT_REMOTE-hot $url
    fi

    run_cmd git fetch $DEFAULT_REMOTE
    run_cmd git fetch $DEFAULT_REMOTE-hot
    run_cmd git remote prune $DEFAULT_REMOTE
    run_cmd git remote prune $DEFAULT_REMOTE-hot

    local branch=refs/remotes/$DEFAULT_REMOTE-hot/$author/$DEFAULT_UPSTREAM_BRANCH/$DEFAULT_WORKING_BRANCH

    if [ -n "$(git show-ref -s $branch)" ]; then
        if [ -z "$DISPLAY" ]; then
            local answer

            echo "No X server running, you'd better start Xorg or Xming for better review experience!" >&2
            read -p "Sure to review in text patch mode?[y/N]" answer
            answer=$(echo "$answer" | tr [:upper:] [:lower:])
            case "$answer" in
                y*)
                    run_cmd git log -p --color $branch
                    ;;
                *)
                    ;;
            esac
        else
            run_cmd gitk $branch \
                         refs/heads/$DEFAULT_WORKING_BRANCH \
                         refs/remotes/$DEFAULT_REMOTE/$DEFAULT_UPSTREAM_BRANCH \
                         refs/remotes/$DEFAULT_REMOTE-hot/$DEFAULT_UPSTREAM_BRANCH-hot &
            run_cmd git gui browser $branch &
        fi
    else
        echo "No branch \"$author/$DEFAULT_UPSTREAM_BRANCH/$DEFAULT_WORKING_BRANCH\" found in remote \"$DEFAULT_REMOTE-hot\"!" >&2
    fi
}


cmd_ls () {
    must_under_project_root

    local pattern="$1"

    if [ -z "$pattern" ]; then
        local module=${MODULE_ROOT#$PROJECT_ROOT/}
        [ -n "$module" ] && echo $module && return 0
    fi

    $REPO forall -c pwd | while read d; do
        echo ${d#$PROJECT_ROOT/}
    done | grep -i "$pattern"
}


cmd_showbranch () {
    must_under_project_root

    local module=${MODULE_ROOT#$PROJECT_ROOT/}
    local path

    if [ -z "$module" ]; then   # in project root directory
        module="$1"
        [ -z "$1" ] &&          # no arguments given
            $REPO forall -c pwd | while read path; do
                cd "$path" && showbranch "$path"
            done ||             # has arguments given
            while shift; do
                must_has_git_dir_in_module $module
                path="$PROJECT_ROOT/$module"
                cd "$path" && showbranch "$path"
                module="$1"
            done
    else
        showbranch "$MODULE_ROOT"
    fi
}


cmd_cherry () {
    must_under_project_root

    local module=${MODULE_ROOT#$PROJECT_ROOT/}
    local path

    if [ -z "$module" ]; then   # in project root directory
        module="$1"
        [ -z "$1" ] &&          # no arguments given
            $REPO forall -c pwd | while read path; do
                cd "$path" && cherry "$path"
            done ||             # has arguments given
            while shift; do
                must_has_git_dir_in_module $module
                path="$PROJECT_ROOT/$module"
                cd "$path" && cherry "$path"
                module="$1"
            done
    else
        cherry "$MODULE_ROOT"
    fi
}


# To emulate behaviour of `git diff ...'
cmd_diff () {
    must_under_project_root

    local module=${MODULE_ROOT#$PROJECT_ROOT/}

    if [ -z "$module" ]; then   # in project root directory
        $REPO forall -c pwd | while read module; do
            cd "$module" && module=${module#$PROJECT_ROOT/} &&
                git diff --src-prefix=a/$module/ --dst-prefix=b/$module/ --color "$@"
        done | less -FRX
    else
        git diff --src-prefix=a/$module/ --dst-prefix=b/$module/ "$@"
    fi
}


cmd_status () {
    must_under_project_root

    $REPO status "$@"
}


cmd_whatupdated () {
    must_under_project_root

    local module=${MODULE_ROOT#$PROJECT_ROOT/}

    if [ -z "$module" ]; then   # in project_root directory
        local path time allpaths alltimes i=0

        module=$1
        [ -z "$1" ] &&          # no arguments given
            while read path; do
                cd "$path" && time=$(last_reflog_time)
                if [ -n "$time" ]; then
                    allpaths[$i]="$path"
                    alltimes[$((i++))]="$time"
                fi
            done < <($REPO forall -c pwd) ||    # has arguments given
            while shift; do
                must_has_git_dir_in_module $module
                path="$PROJECT_ROOT/$module"
                cd "$path" && time=$(last_reflog_time)
                if [ -n "$time" ]; then
                    allpaths[$i]="$path"
                    alltimes[$((i++))]="$time"
                fi
                module=$1
            done

        [ $i -eq 0 ] && return 0

        local maxtime=0
        for ((i=0; i < ${#allpaths[@]}; ++i)); do
            [ $maxtime -lt ${alltimes[$i]} ] &&
                maxtime=${alltimes[$i]}
        done

        for ((i=0, j=0; i < ${#allpaths[@]}; ++i)); do
            [ $(expr $maxtime - ${alltimes[$i]}) -le $UPDATE_INTERVAL ] &&
                cd "${allpaths[$i]}" && whatupdated "${allpaths[$i]}"
        done | less -FRX
    else
        whatupdated "$MODULE_ROOT"
    fi
}


cmd_forall () {
    must_under_project_root

    $REPO forall -c "$@"
}


cmd_editlog () {
    must_under_module_root

    local base
    local rev=$(git rev-parse $1)
    local current_branch=$(git symbolic-ref HEAD)
    local tmp_branch=${current_branch#refs/heads/}-editlog

    if git show-ref $tmp_branch >/dev/null; then
        echo "$tmp_branch exists! Delete it after you make sure it's useless." >&2
        return 1
    fi

    if [ -z "$rev" ]; then
        echo "Which commit do you want to edit log?" >&2
        return 1
    fi

    base=$(git merge-base $rev HEAD)
    if [ "$base" != "$rev" ]; then
        echo "Commit \"$1\" isn't on current branch!" >&2
        return 1
    fi

    [ "$1" != "$rev" ] && echo "[$1] is commit $rev"

    run_cmd git stash save "\"Before editlog for $rev on $current_branch\""
    if [ $rev = $(git rev-parse HEAD) ]; then
        run_cmd git commit --amend
    else
        run_cmd git checkout -b $tmp_branch $rev
        run_cmd git commit --amend
        run_cmd git checkout ${current_branch#refs/heads/}

        while :; do
            read -p "Sure to edit log for commit $rev on branch $current_branch?[y/N]"
            REPLY=$(echo "$REPLY" | tr [:upper:] [:lower:])
            case "$REPLY" in
                y*)
                    run_cmd git rebase --onto $tmp_branch $rev
                    break
                    ;;
                n*)
                    break
                    ;;
                *)
                    ;;
            esac
        done

        run_cmd git branch -D $tmp_branch
    fi
    git stash list | head -1 | grep -q "Before editlog" &&
        run_cmd git stash pop
}


cmd_log () {
    must_under_project_root

    local module modules fds i=0 n
    local buffers dates date j k

    # save names for every modules and open named pipes to `git log' for them
    while read module; do
        cd "$module" && module=${module#$PROJECT_ROOT/} && {
            modules[$i]="$module"
            eval exec "$((i+100))<" <(git log --color --date=iso --date-order "$@") &&
                fds[$i]=$((i+100)) ||
                fds[$i]=0
            dates[$((i++))]=0
        }
    done < <($REPO forall -c pwd 2>/dev/null)

    n=$i

    # initialize 'dates', save lines from "^commit .*" to "^Date: .*" to 'buffers'
    # because we require the timestamp of each commit to decide whether output it
    for ((i = 0; i < $n; i++)); do
        [ ${fds[$i]} -eq 0 ] && continue

        while read -u ${fds[$i]}; do
            [ -z "${buffers[$i]}" ] && buffers[$i]="module ${modules[$i]}"
            buffers[$i]="${buffers[$i]}\n$REPLY"
            [ 8 -eq $(expr "$REPLY" : "Date:   ") ] &&
                dates[$i]=$(date -d "${REPLY#Date:   }" +%s) &&
                break
        done
    done

    # find the latest commit, in modules[j]
    date=0
    j=0
    for ((i = 0; i < $n; i++)); do
        [ $date -lt ${dates[$i]} ] && date=${dates[$i]} && j=$i
    done

    [ $date -eq 0 ] && return 0

    # do a N-way merge sort, output logs of each modules
    while : ; do
        # find the next latest commit, in modules[k]
        date=0
        k=0
        for ((i = 0; i < $n; i++)); do
            [ $i -ne $j -a $date -lt ${dates[$i]} ] && date=${dates[$i]} && k=$i
        done

        # output logs in modules[j] from dates[j] to dates[k]
        [ -n "${buffers[$j]}" ] && {
            echo -e "${buffers[$j]}"
            buffers[$j]=""
        }
        while read -u ${fds[$j]}; do
            # XXX: how to use group in expr? it's better to write
            # '^\(\[[0-9;]m\)\?commit '
            if [ 0 -lt $(expr "$REPLY" : '\?\[\?[0-9;]*m\?commit ') ]; then
                buffers[$j]="module ${modules[$j]}\n$REPLY"

                while read -u ${fds[$j]}; do
                    buffers[$j]="${buffers[$j]}\n$REPLY"
                    [ 8 -eq $(expr "$REPLY" : "Date:   ") ] &&
                        dates[$j]=$(date -d "${REPLY#Date:   }" +%s) &&
                        break
                done

                [ ${dates[$j]} -ge ${dates[$k]} ] && {
                        echo -e "${buffers[$j]}"
                        buffers[$j]=""
                    } ||
                    break
            else
                echo "$REPLY"
            fi
        done

        # all logs of modules[j] have been outputed
        [ -z "${buffers[$j]}" ] && dates[$j]=0

        # no next latest commit
        [ $date -eq 0 ] && return 0

        # next loop
        j=$k
    done | less -FRX
}

######################## main entry ####################################
trap finalize EXIT

cmd="${1//-}"
shift

[ -z "$cmd" ] && cmd_help && exit 0

if has_sub_command "$cmd"; then
    # initialize some global variables
    initialize

    # execute the sub command
    cmd_$cmd "$@"
else
    echo "Unkown command, run 'rrp help' for help information." >&2
fi

