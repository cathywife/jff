#!/usr/bin/env perl
use strict;
use warnings;
use Data::Dumper;
use File::Spec;
use Getopt::Long;
use HTTP::Response;
use JSON;
use Log::Log4perl qw(:easy);
use POE qw(Component::Server::TCP Filter::HTTPD);
use Try::Tiny;


my $g_port = 9999;
my $g_libexec_path = File::Spec->curdir;

#
# Initialize Log4perl
#
Log::Log4perl->easy_init({
        level   => $DEBUG,
        layout  => "[%d] %-5p (%P) %F{1}:%-4L - %m%n",
        #file   => ">plumber.log",
    });


#
# Process command line options
#
GetOptions("port=i"     => \$g_port,
           "exec=s"     => \$g_libexec_path);
die "Bad port $g_port\n" if $g_port <= 0 || $g_port > 65535;
die "Bad directory \"$g_libexec_path\"\n" unless -d $g_libexec_path;

INFO "listen on port $g_port";

#
# Start server
#
POE::Component::Server::TCP->new(
    Port                => $g_port,
    Started             => \&on_master_started,
    ClientFilter        => "POE::Filter::HTTPD",
    ClientConnected     => \&on_client_connected,
    ClientDisconnected  => \&on_client_disconnected,
    ClientInput         => \&on_client_input,
);

POE::Kernel->run;
exit;


######################################################################
sub on_client_connected {
    my ($kernel, $heap) = @_[KERNEL, HEAP];

    INFO "client connected from $heap->{remote_ip} port $heap->{remote_port}";

    register_HUP_INT_TERM_handler($kernel);
}


sub on_client_disconnected {
    my $heap = $_[HEAP];

    INFO "client disconnected from $heap->{remote_ip} port $heap->{remote_port}";
}


sub on_client_input {
    my ($heap, $kernel, $request) = @_[HEAP, KERNEL, ARG0];

    # It's a response for the client if there was a problem
    if ($request->isa("HTTP::Response")) {
        my $response = $request;

        $request = $response->request;
        WARN "bad request: ", $request->message if $request;

        $_[HEAP]{client}->put($response);
        $_[KERNEL]->yield("shutdown");
        return;
    }

    try {
        my $response = handle_request($request);
        $heap->{client}->put($response);
    } catch {
        ERROR "caught exception when handle request: $_";

        my $response = compose_http_response(500,
            "Caught exception when handle request!");
        $heap->{client}->put($response);

        $kernel->yield("shutdown");
    };
}


sub handle_request {
    my ($request) = @_;
    my $response;
    my $ref;

    if ($request->content) {
        $ref = decode_json $request->content;
    } else {
        return compose_http_response(200,
            "Not a JSON message, current time: " .
            scalar(localtime), "text/plain");
    }

    if (defined $ref && ref($ref) eq 'ARRAY' && @$ref > 0) {
        # TODO
    } else {
        $response = compose_http_response(400,
            "Invalid JSON message: " . $request->content);
    }

    return $response;
}


sub sig_HUP_INT_TERM {
    my ($kernel, $heap, $sig) = @_[KERNEL, HEAP, ARG0];

    my $who = "listener";
    if (! exists $heap->{listener}) {
        $who = "client";
    }

    WARN "$who got signal $sig!";

    $kernel->yield("shutdown");
    $kernel->sig_handled();
}


sub register_HUP_INT_TERM_handler {
    my ($kernel) = @_;

    $kernel->state("sig_HUP_INT_TERM", \&sig_HUP_INT_TERM);
    $kernel->sig(HUP    => "sig_HUP_INT_TERM");
    $kernel->sig(INT    => "sig_HUP_INT_TERM");
    $kernel->sig(TERM   => "sig_HUP_INT_TERM");
}


sub on_master_started {
    my $kernel = $_[KERNEL];

    register_HUP_INT_TERM_handler($kernel);
}


sub compose_http_response {
    my ($code, $content, $type) = @_;
    my $length;

    $type ||= "application/json";
    $content = encode_json {message => $content} if $code != 200;
    {
        use bytes;
        $length = length($content);
    }

    my $response = HTTP::Response->new($code);
    $response->push_header("Content-Type", $type);
    $response->push_header("Content-Length", $length);
    $response->content($content);

    return $response;
}

