如何编写出能确保正确的程序？
  * 语法
  * 验证

良好的语法能帮助验证，核心语法应该是机器无关的，
表达纯数学概念，语言实现本身应该尽量用语言自身
实现，除非涉及硬件相关特性。

1. S-exp 作为基础语法，便于分析
2. 核心数据类型只有一种：整数
整数默认无限精度，通过显式指定可以使用机器精度；
浮点数表示为分数，也就是整数对，需要显式转换成机器精度；
字符、字符串都是整数序列。
3. 数据类型自动推导；
4. 默认用抽象数据类型，具体实现用标注，比如
Set a /* RBTreeSet */ = .....
5. 自顶向下设计，自底向上实现。
6. 运行环境的实际限制是存在的，但当这些实际限制都没有
达到时，应该是能避免程序自身的非逻辑错误。
7. 不可验证的部分必须独立出来，提供接口，针对接口验证。
8. 模式匹配有利于编写正确的程序
9. 静态强类型，需要动态强类型的地方必须显式指定。
10. 单次赋值

Common Lisp/Scheme  语法一致，简洁，symbol 的概念，真正的集成开发
OCaml/SML           模式匹配，类型推导，高效的虚拟机
Haskell             纯函数式
Erlang              单次赋值，模式匹配，尾递归优化
Smalltalk           自举实现，真正的集成开发
Maxima, Mathematica 精确计算
Parrot              PMC 的设计

target: llvm, gcc, parrot...
neko, lightning
Microsoft Singularity

零缺陷编程
程序正确性验证
root of lisp

=======================================================================
发信人: friedcat (suac), 信区: FuncProgram
标  题: Re: Smalltalk 实现之 Squeak
发信站: 水木社区 (Tue Sep 18 16:29:53 2007), 站内

squeak最特殊的地方在于它是完全用自己写的，包括vm。
一般的编译器自举不出奇，反正最后产生的是机器码，但是用语言本身写自己的vm，这个语
言又相对高级，想做到效率不低，就很难了。
squeak的实现着取了smalltalk的一个大子集，这个子集的选择依照两个原则：1.尽量保持
smalltalk的表达能力。2.尽量能简单地翻译成c。然后用这个大子集写smalltalk的vm，最
后用smalltalk写一个把这个子集翻译成c的程序。
这种做法的好处是你可以在smalltalk下修改和调试vm，从而可以利用smalltalk强大的开发
和调试环境，而不是在修改编译器时用smalltalk，修改vm时又去用相对比较手工化的c环境
。
后来的很多项目学习了这种方式，比如scheme48,pypy和rubinius。

